{"version":3,"file":"app.bundle.js","mappings":"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","sources":["webpack://orbs-game/./src/config.ts","webpack://orbs-game/./src/types/decorators.ts","webpack://orbs-game/./src/components/Tools.ts","webpack://orbs-game/./src/classes/Collider.ts","webpack://orbs-game/./src/classes/Pathfinder.ts","webpack://orbs-game/./src/classes/Renderer.ts","webpack://orbs-game/./src/classes/Board.ts","webpack://orbs-game/./src/app.ts"],"sourcesContent":["/** All colors of board's tiles. */\r\nexport const BoardTilesColors = [\r\n    {\r\n        id: 'r',\r\n        name: 'red'\r\n    },\r\n    {\r\n        id: 'o',\r\n        name: 'orange'\r\n    },\r\n    {\r\n        id: 'y',\r\n        name: 'yellow'\r\n    },\r\n    {\r\n        id: 'g',\r\n        name: 'green'\r\n    },\r\n    {\r\n        id: 'c',\r\n        name: 'cyan'\r\n    },\r\n    {\r\n        id: 'b',\r\n        name: 'blue'\r\n    },\r\n    {\r\n        id: 'v',\r\n        name: 'violet'\r\n    }\r\n]\r\n\r\n/** Types of board tiles. */\r\nexport const BoardTilesTypes = {\r\n    finish: 'f',\r\n    none: '-',\r\n    obstacle: 'x',\r\n    start: 's'\r\n}\r\n\r\n/** Additional game data. */\r\nexport const GameData = {\r\n    patternLength: 3,\r\n    /** Initial balls quantity. */\r\n    quantityOfInitialBalls: 3,\r\n    /** How many new balls should be generated in next round. */\r\n    quantityOfRoundBalls: 3,\r\n}","// noinspection JSUnusedLocalSymbols\r\n\r\n/** Logs additional information with start function. */\r\nexport function logStart(target: any, name: string, descriptor: any): void {\r\n    console.log('[INFO] Creating board. Loading data.');\r\n}\r\n\r\n/** Measures time that takes to execute a decorated function. */\r\nexport const measurePerformance = (message: string) => (target: object, propertyKey: string, descriptor: PropertyDescriptor) => {\r\n    const originalMethod = descriptor.value;\r\n\r\n    descriptor.value = function (...args) {\r\n        const start = performance.now();\r\n        const result = originalMethod.apply(this, args);\r\n        const finish = performance.now();\r\n\r\n        console.log(`[INFO] Module { ${message} } took: ${finish - start} ms.`);\r\n        return result;\r\n    };\r\n}","export default class Tools {\r\n  /**\r\n   * Returns number from (min, max) range - not inclusive.\r\n   * @static\r\n   * @param {number} min - min of range.\r\n   * @param {number} max - max of range.\r\n   */\r\n  static getRandomInt(min: number, max: number): number {\r\n    min = Math.ceil(min);\r\n    max = Math.floor(max);\r\n    return Math.floor(Math.random() * (max - min)) + min;\r\n  }\r\n\r\n  /**\r\n   * Returns number from <min, max> range - inclusive.\r\n   * @static\r\n   * @param {number} min - min of range.\r\n   * @param {number} max - max of range.\r\n   */\r\n  static getRandomIntInclusive(min: number, max: number): number {\r\n    min = Math.ceil(min);\r\n    max = Math.floor(max);\r\n    return Math.floor(Math.random() * (max - min + 1)) + min;\r\n  }\r\n\r\n  /**\r\n   * Removes duplicated items from array.\r\n   * @param array\r\n   */\r\n  static removeArrayDuplicates(array: any[]): any[] {\r\n    return array.filter((v,i,a)=>a.findIndex(t=>(JSON.stringify(t) === JSON.stringify(v)))===i);\r\n  }\r\n}","import {ColliderInterface} from '../types/classes-interfaces';\r\nimport {BoardData, BoardMapTileData} from '../types/interfaces';\r\nimport {GameData} from '../config';\r\nimport {measurePerformance} from '../types/decorators';\r\nimport Tools from '../components/Tools';\r\n\r\nconsole.log('Loaded: Collider.ts');\r\n\r\n\r\n/**\r\n *  Checks and searches pattern to detect balls possible to beat.\r\n */\r\nexport default class Collider implements ColliderInterface {\r\n    /** Data about the board. */\r\n    private readonly board: BoardData;\r\n\r\n    constructor(height: number, width: number) {\r\n        this.board = {\r\n            height: height,\r\n            width: width\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Searches for all balls that can be deleted.\r\n     * @param boardMap - board map.\r\n     * @return tilesArr - list of all balls that can be deleted.\r\n     */\r\n    @measurePerformance('pattern detection')\r\n    checkAllAxis(boardMap: BoardMapTileData[]): BoardMapTileData[] {\r\n        let tilesToPurge: BoardMapTileData[] = [];\r\n\r\n        // check columns and rows\r\n        tilesToPurge = tilesToPurge.concat(this.checkAxis(boardMap, 'column'));\r\n        tilesToPurge = tilesToPurge.concat(this.checkAxis(boardMap, 'row'));\r\n\r\n        // check slants\r\n        tilesToPurge = tilesToPurge.concat(this.checkSlants(boardMap));\r\n\r\n        // remove duplicates\r\n        tilesToPurge = Tools.removeArrayDuplicates(tilesToPurge);\r\n\r\n        return tilesToPurge;\r\n    }\r\n\r\n    /**\r\n     * Searches horizontally and vertically for balls that can be deleted.\r\n     * @param boardMap - board map.\r\n     * @param direction - direction in which board will be searched.\r\n     * @return tilesArr - list of all balls that can be deleted in selected direction.\r\n     */\r\n    checkAxis(boardMap: BoardMapTileData[], direction: 'column' | 'row'): BoardMapTileData[] {\r\n        let tilesToPurge: BoardMapTileData[] = [];\r\n\r\n        // set boardMap axis to search\r\n        let arrDirectionFirst: number;\r\n        let arrDirectionSecond: number;\r\n        switch (direction) {\r\n            case 'column':\r\n                arrDirectionFirst = this.board.width;\r\n                arrDirectionSecond = this.board.height;\r\n                break;\r\n            case 'row':\r\n                arrDirectionFirst = this.board.height;\r\n                arrDirectionSecond = this.board.width;\r\n                break;\r\n        }\r\n\r\n        for (let i = 0; i < arrDirectionFirst; i++) {\r\n            // select tile, it's color and set color's occurrences\r\n            let colorOccurrences = 0;\r\n\r\n            let tile: BoardMapTileData = direction === 'column' ? boardMap[0][i] : boardMap[i][0];\r\n            let tileColor: string = tile.color;\r\n\r\n            // set flag that checks if tilesList should be merged with tilesToPurge\r\n            let pushNext = false;\r\n            let tilesList: BoardMapTileData[] = [];\r\n\r\n            // select next tiles from axis\r\n            for (let j = 0; j < arrDirectionSecond; j++) {\r\n                // set boardMap coordinates variables\r\n                let x: number;\r\n                let y: number;\r\n                switch (direction) {\r\n                    case 'column':\r\n                        x = i;\r\n                        y = j;\r\n                        break;\r\n                    case 'row':\r\n                        x = j;\r\n                        y = i;\r\n                        break;\r\n                }\r\n\r\n                // select next tile, check if it has the same color as last; increase color occurrences and continue check or else select new color and repeat\r\n                let nextTile = boardMap[y][x];\r\n                if (tileColor && nextTile.color === tileColor) {\r\n                    colorOccurrences++;\r\n\r\n                    tilesList.push(nextTile);\r\n\r\n                    // set merging flag to true, when occurrences match set length\r\n                    if (colorOccurrences >= GameData.patternLength)\r\n                        pushNext = true;\r\n                } else {\r\n                    // reset all values\r\n                    colorOccurrences = 1;\r\n                    tile = boardMap[y][x]\r\n                    tileColor = tile.color;\r\n\r\n                    pushNext = false;\r\n                    tilesList = [tile];\r\n                }\r\n\r\n                // merge tilesList to tilesToPurge\r\n                if (pushNext)\r\n                    tilesToPurge = tilesToPurge.concat(tilesList);\r\n            }\r\n        }\r\n\r\n        return tilesToPurge;\r\n    }\r\n\r\n    /**\r\n     * Searches for balls that can be in a slant.\r\n     * @param boardMap - board map.\r\n     * @param x - horizontal coordinate of slant's start.\r\n     * @param y - vertical coordinate of slant's start.\r\n     * @param direction - direction towards which slant is leaning.\r\n     * @param max - max height or width that loop will iterate over.\r\n     * @return tilesArr - list of all balls that can be deleted in a slant.\r\n     */\r\n    checkSlant(boardMap: BoardMapTileData[], x: number, y: number, direction: 1 | -1, max: number): BoardMapTileData[] {\r\n        let tilesToPurge: BoardMapTileData[] = [];\r\n\r\n        // select tile, it's color and set color's occurrences\r\n        let colorOccurrences: number = 1;\r\n\r\n        let tile: BoardMapTileData = boardMap[y][x];\r\n        let tileColor: string = tile.color;\r\n\r\n        // set flag that checks if tilesList should be merged with tilesToPurge\r\n        let pushNext = false;\r\n        let tilesList: BoardMapTileData[] = [tile];\r\n\r\n        while (max) {\r\n            // overflow safety\r\n            if (x + direction > this.board.width - 1 || x + direction < 0 || y + 1 > this.board.height - 1)\r\n                break;\r\n\r\n            // select next tile, check if it has the same color as last; increase color occurrences and continue check or else select new color and repeat\r\n            let nextTile = boardMap[y + 1][x + direction];\r\n            if (tileColor && tileColor === nextTile.color) {\r\n                colorOccurrences++;\r\n\r\n                tilesList.push(nextTile);\r\n\r\n                // set merging flag to true, when occurrences match set length\r\n                if (colorOccurrences >= GameData.patternLength)\r\n                    pushNext = true;\r\n            } else {\r\n                // reset all values\r\n                colorOccurrences = 1;\r\n                tile = boardMap[y + 1][x + direction];\r\n                tileColor = tile.color;\r\n                tilesList = [tile];\r\n            }\r\n\r\n            // merge tilesList to tilesToPurge\r\n            if (pushNext) {\r\n                pushNext = false;\r\n                tilesToPurge = tilesToPurge.concat(tilesList);\r\n                tilesList = [];\r\n            }\r\n\r\n            // increment coordinates values\r\n            direction === 1 ? x++ : x--;\r\n            y++;\r\n        }\r\n\r\n        return tilesToPurge;\r\n    }\r\n\r\n    /**\r\n     * Searches for balls that can be in all slants.\r\n     * @param boardMap - board map.\r\n     * @return tilesArr - list of all balls that can be deleted in all slants.\r\n     */\r\n    checkSlants(boardMap: BoardMapTileData[]): BoardMapTileData[] {\r\n        let tilesToPurge: BoardMapTileData[] = [];\r\n\r\n        for (let i = 0; i < this.board.width - (GameData.patternLength - 1); i++) {\r\n            tilesToPurge = tilesToPurge.concat(this.checkSlant(boardMap, i, 0, 1, this.board.width - 1));\r\n            tilesToPurge = tilesToPurge.concat(this.checkSlant(boardMap, this.board.width - 1, this.board.height - GameData.patternLength - i, -1, this.board.height - 1));\r\n        }\r\n\r\n        for (let i = 0; i < this.board.height; i++) {\r\n            tilesToPurge = tilesToPurge.concat(this.checkSlant(boardMap, 0, i, 1, this.board.width - 1));\r\n            tilesToPurge = tilesToPurge.concat(this.checkSlant(boardMap, i, 0, -1, this.board.height - 1));\r\n        }\r\n\r\n        return tilesToPurge;\r\n    }\r\n}","import {BoardProcess, BoardProcessTile, BoardData, Coordinates, BoardMap} from '../types/interfaces';\r\nimport {BoardTilesTypes} from '../config';\r\nimport {measurePerformance} from '../types/decorators';\r\nimport {PathfinderInterface} from '../types/classes-interfaces';\r\n\r\nconsole.log('Loaded: Pathfinder.ts');\r\n\r\n\r\n/**\r\n * Class to calculate the shortest path between start and finish.\r\n */\r\nexport default class Pathfinder implements PathfinderInterface {\r\n    /** Board height and width. */\r\n    private readonly board: BoardData;\r\n    /** Flag that turns on/off debug logs. */\r\n    private readonly debugMode: boolean;\r\n    /** Array with offset data. Useful while searching tiles around a selected tile. */\r\n    private readonly searchOffsetArr: Array<Coordinates>;\r\n\r\n    /** Finish point data. */\r\n    private finish: BoardProcessTile\r\n    /** Start point data. */\r\n    private start: BoardProcessTile;\r\n\r\n\r\n    /**\r\n     * Creates basic pathfinder data.\r\n     * @param height - height of the board.\r\n     * @param width - width of the board.\r\n     */\r\n    constructor(height: number, width: number) {\r\n        // board dimensions\r\n        this.board = {\r\n            height: height,\r\n            width: width\r\n        };\r\n        // debug flag\r\n        this.debugMode = false;\r\n\r\n        // offset which will be searched around selected\r\n        this.searchOffsetArr = [\r\n            {\r\n                x: 0,\r\n                y: -1\r\n            },\r\n            {\r\n                x: -1,\r\n                y: 0\r\n            },\r\n            {\r\n                x: 1,\r\n                y: 0\r\n            },\r\n            {\r\n                x: 0,\r\n                y: 1\r\n            }\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Checks if start and finish tiles are neighbours.\r\n     * @private\r\n     * @param boardProcess - boardProcess array.\r\n     * @return areNeighbours - are tiles neighbours.\r\n     */\r\n    private checkIfEndPointsAreNeighbors(boardProcess: BoardProcess): boolean {\r\n        for (let i = 0; i < this.searchOffsetArr.length; i++) {\r\n            if (this.checkOffsetOutOfIndex(this.finish, i))\r\n                continue;\r\n            if (boardProcess[this.finish.y + this.searchOffsetArr[i].y][this.finish.x + this.searchOffsetArr[i].x].type === 's')\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Check if offset will be out of index.\r\n     * @private\r\n     * @param tileData - tile to which offset will be checked.\r\n     * @param offsetID - id of offset data in searchOffsetArr array. Number 0 - 3.\r\n     * @return isOutOfIndex - is offset out of index or not.\r\n     */\r\n    private checkOffsetOutOfIndex(tileData: BoardProcessTile, offsetID: number): boolean {\r\n        if (tileData.x + this.searchOffsetArr[offsetID].x < 0 || tileData.x + this.searchOffsetArr[offsetID].x > this.board.width - 1)\r\n            return true;\r\n        else if (tileData.y + this.searchOffsetArr[offsetID].y < 0 || tileData.y + this.searchOffsetArr[offsetID].y > this.board.height - 1)\r\n            return true;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Find the shortest path between two points marked as start and finish.\r\n     * @param board - board array.\r\n     * @return shortestPath - array with the shortest path.\r\n     */\r\n    @measurePerformance('pathfinding')\r\n    findPath(board: BoardMap): Array<Coordinates> {\r\n        // create new array of boardProcess objects - coordinates and other tile data (BoardProcessTile)\r\n        let boardProcess: BoardProcess = [];\r\n        for (let i = 0; i < this.board.height; i++) {\r\n            boardProcess.push([]);\r\n            for (let j = 0; j < this.board.width; j++) {\r\n                boardProcess[i].push({\r\n                    pathHelper: -1,\r\n                    x: j,\r\n                    y: i,\r\n                    wasSearched: false\r\n                });\r\n                switch (board[i][j].type) {\r\n                    case BoardTilesTypes.finish:\r\n                        boardProcess[i][j].type = BoardTilesTypes.finish;\r\n                        this.finish = boardProcess[i][j];\r\n                        break;\r\n                    case BoardTilesTypes.none:\r\n                        boardProcess[i][j].type = BoardTilesTypes.none;\r\n                        break;\r\n                    case BoardTilesTypes.obstacle:\r\n                        boardProcess[i][j].type = BoardTilesTypes.obstacle;\r\n                        break;\r\n                    case BoardTilesTypes.start:\r\n                        Object.assign(boardProcess[i][j], {\r\n                            type: BoardTilesTypes.start,\r\n                            wasSearched: true\r\n                        });\r\n                        this.start = boardProcess[i][j];\r\n                        break;\r\n                    default:\r\n                        console.error('[ERROR] Board corrupted. ' + `x: ${i} y: ${j}, type: ${board[i][j]}`, board);\r\n                }\r\n            }\r\n        }\r\n\r\n        // search for shortest path\r\n        let foundFinish = false;\r\n        let pathHelper = 0;\r\n        let tilesToCheckArr: Array<BoardProcessTile> = [boardProcess[this.start.y][this.start.x]];\r\n\r\n        while(!foundFinish) {\r\n            // check all tile from the list\r\n            let tilesToCheckArrCopy = [...tilesToCheckArr];\r\n            for (let i = 0; i < tilesToCheckArrCopy.length; i++) {\r\n                // check all tiles around tileToCheck\r\n                let tileToCheck = tilesToCheckArrCopy[i];\r\n                for (let j = 0; j < this.searchOffsetArr.length; j++) {\r\n                    // check if offset is out of index\r\n                    if (this.checkOffsetOutOfIndex(tileToCheck, j))\r\n                        continue;\r\n\r\n                    // select tile from boardProcessArr and check if it has been already searched; if not, fill with pathHelper number\r\n                    let tileAround = boardProcess[tileToCheck.y + this.searchOffsetArr[j].y][tileToCheck.x + this.searchOffsetArr[j].x];\r\n                    if (tileAround.wasSearched)\r\n                        continue;\r\n                    tileAround.wasSearched = true;\r\n\r\n                    // check if tile is an obstacle\r\n                    if (tileAround.type === BoardTilesTypes.obstacle)\r\n                        continue;\r\n\r\n                    // set pathHelper number and add to list to further search\r\n                    tileAround.pathHelper = pathHelper;\r\n                    tilesToCheckArr.push(tileAround);\r\n\r\n                    // check if finish has been found\r\n                    if (tileAround.type === BoardTilesTypes.finish) {\r\n                        foundFinish = true;\r\n                        break;\r\n                    }\r\n                }\r\n                // remove checked tile from list\r\n                tilesToCheckArr.splice(tilesToCheckArr.indexOf(tileToCheck), 1);\r\n            }\r\n\r\n            // check if there are tiles to check\r\n            if (tilesToCheckArr.length === 0)\r\n                break ;\r\n            pathHelper++;\r\n        }\r\n\r\n        // return shortest path\r\n        return this.reverseSearch(boardProcess);\r\n    }\r\n\r\n    /**\r\n     * Search for the shortest path from finish to start.\r\n     * @private\r\n     * @param boardProcess - boardProcess array.\r\n     * @return shortestPath - array with the shortest path.\r\n     */\r\n    private reverseSearch(boardProcess: BoardProcess): Array<Coordinates> {\r\n        let pathArr: Array<Coordinates> = [this.finish];\r\n\r\n        // check if start is next to finish\r\n        if (this.checkIfEndPointsAreNeighbors(boardProcess))\r\n            return pathArr;\r\n\r\n        // search for the shortest path\r\n        let lastTile: BoardProcessTile = this.finish;\r\n        let pathCreated = false;\r\n\r\n        while(!pathCreated) {\r\n            let lastTileBeforeSearch = lastTile;\r\n\r\n            // check all tiles around lastTile\r\n            for (let i = 0; i < this.searchOffsetArr.length; i++) {\r\n                // check if offset is out of index\r\n                if (this.checkOffsetOutOfIndex(lastTile, i))\r\n                    continue;\r\n\r\n                let selectedTile = boardProcess[lastTile.y + this.searchOffsetArr[i].y][lastTile.x + this.searchOffsetArr[i].x];\r\n\r\n                // check if selectedTile is the shortest path to start\r\n                if (selectedTile.pathHelper === lastTile.pathHelper - 1) {\r\n                    pathArr.push(selectedTile)\r\n                    lastTile = selectedTile;\r\n                }\r\n\r\n                // check if start has been found\r\n                if (selectedTile.pathHelper === 0) {\r\n                    pathCreated = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // check if there is next tile or path is blocked by obstacles\r\n            if (lastTile === lastTileBeforeSearch) {\r\n                if (this.debugMode)\r\n                    console.log('[DEBUG] Hovered tile cannot be accessed.');\r\n\r\n                pathCreated = true;\r\n                return [];\r\n            }\r\n        }\r\n\r\n        if (this.debugMode)\r\n            console.log('[DEBUG] Shortest path length:', pathArr.length);\r\n\r\n        // return shortest path\r\n        return pathArr;\r\n    }\r\n}","import Board from './Board';\r\nimport {BoardData, Coordinates, EndPoints, BoardMapTile, BoardMapTileData} from '../types/interfaces';\r\nimport {BoardTilesTypes} from '../config';\r\nimport {DeletedBallsEvent, GameEndedEvent, GeneratedBallsEvent, PreviewedBallsEvent} from '../types/events';\r\nimport {RendererInterface} from '../types/classes-interfaces';\r\n\r\nconsole.log('Loaded: Renderer.ts');\r\n\r\n\r\n/**\r\n * Class that renders all DOM operation, inputs and game output.\r\n */\r\nexport default class Renderer implements RendererInterface {\r\n    /** Data about the board. */\r\n    private readonly board: BoardData;\r\n\r\n    /** Don't render path before selecting start flag. */\r\n    private renderPathFlag: boolean;\r\n    /** Selected start tile. */\r\n    private selectedStart: HTMLTableCellElement | null;\r\n\r\n    /** Data about start and finish points. */\r\n    private readonly endPoints: EndPoints;\r\n    /** Last path that was rendered on the board. */\r\n    private lastRenderedPath: Coordinates[];\r\n\r\n\r\n    /**\r\n     * Creates new renderer for board.\r\n     * @param board - board instance that will allow using dynamic board data.\r\n     * @param height - board height.\r\n     * @param width - board width.\r\n     */\r\n    constructor(board: Board, height: number, width: number) {\r\n        this.board = {\r\n            height: height,\r\n            instance: board,\r\n            width: width\r\n        };\r\n\r\n        this.renderPathFlag = false;\r\n        this.selectedStart = null;\r\n\r\n        this.endPoints = {\r\n            finish: null,\r\n            start: null\r\n        };\r\n\r\n        this.lastRenderedPath = [];\r\n    }\r\n\r\n    /**\r\n     * Clears div with id 'js-display', and appends new content.\r\n     * @private\r\n     * @static\r\n     * @param element - element that will be appended.\r\n     */\r\n    private static clearAndAppendDisplay(element: HTMLElement): void {\r\n        let display = document.getElementById('js-display') as HTMLDivElement;\r\n        while (display.firstChild)\r\n            display.removeChild(display.firstChild);\r\n        display.appendChild(element);\r\n    }\r\n\r\n    /**\r\n     * Un-render balls that were deleted.\r\n     * @private\r\n     * @param balls - balls to un-render.\r\n     */\r\n    private static clearDeletedBalls(balls: BoardMapTileData[]): void {\r\n        for (let i = 0; i < balls.length; i++)\r\n            document.querySelector(`[data-x=\"${balls[i].x}\"][data-y=\"${balls[i].y}\"]`).firstChild.remove();\r\n    }\r\n\r\n    /**\r\n     * Clears recently rendered path between points.\r\n     * @private\r\n     * @param hasAfterimage - should afterimage of last path be rendered.\r\n     * @param duration - duration of afterimage in ms.\r\n     */\r\n    private clearLastRenderedPath(hasAfterimage?: boolean, duration?: number): void {\r\n        let copyLastRenderedPath = [...this.lastRenderedPath];\r\n        for (let i = 0; i < copyLastRenderedPath.length; i++) {\r\n            let pathTile = document.querySelector(`[data-x=\"${copyLastRenderedPath[i].x}\"][data-y=\"${copyLastRenderedPath[i].y}\"]`);\r\n\r\n            if (!hasAfterimage )\r\n                pathTile.classList.remove('ball--path');\r\n            else {\r\n                pathTile.classList.add('ball--path-afterimage');\r\n                pathTile.classList.remove('ball--path');\r\n\r\n                setTimeout(() => {\r\n                    for (let i = 0; i < copyLastRenderedPath.length; i++)\r\n                        pathTile.classList.remove('ball--path-afterimage');\r\n                }, duration);\r\n            }\r\n        }\r\n\r\n        this.lastRenderedPath = [];\r\n    }\r\n\r\n    /**\r\n     * Generates new board with height and width set in class object, then appends it to the DOM.\r\n     */\r\n    renderBoard(): void {\r\n        let boardDOM: HTMLTableElement = document.createElement('table');\r\n        boardDOM.classList.add('board');\r\n\r\n        for (let i: number = 0; i < this.board.height; i++) {\r\n            let row: HTMLTableRowElement = document.createElement('tr');\r\n\r\n            for (let j: number = 0; j < this.board.width; j++) {\r\n                let cell: HTMLTableCellElement = document.createElement('td');\r\n\r\n                cell.classList.add('board__cell');\r\n                cell.setAttribute('data-x', j.toString());\r\n                cell.setAttribute('data-y', i.toString());\r\n                this.setTileEvents(cell);\r\n\r\n                row.appendChild(cell);\r\n            }\r\n            boardDOM.appendChild(row);\r\n        }\r\n\r\n        Renderer.clearAndAppendDisplay(boardDOM);\r\n    }\r\n\r\n    /**\r\n     * Renders balls on the DOM board.\r\n     * @static\r\n     * @private\r\n     * @param ballsArr - balls to render.\r\n     */\r\n    private static renderBalls(ballsArr: BoardMapTile[]): void {\r\n        for (let i = 0; i < ballsArr.length; i++) {\r\n            let ballData = ballsArr[i];\r\n            let ball = document.createElement('div');\r\n\r\n            ball.classList.add('ball', 'ball-color--' + ballData.color);\r\n            document.querySelector(`[data-x=\"${ballData.x}\"][data-y=\"${ballData.y}\"]`).appendChild(ball);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders path between start set in class object and specified tile.\r\n     * @private\r\n     * @param tile - end point of path.\r\n     */\r\n    private renderPath(tile: HTMLTableCellElement): void {\r\n        this.clearLastRenderedPath();\r\n\r\n        let endpoints = {\r\n            finish: {\r\n                  x: parseInt(tile.dataset.x),\r\n                  y: parseInt(tile.dataset.y)\r\n              },\r\n            start: this.endPoints.start\r\n        };\r\n\r\n        let path = this.board.instance.getPath(endpoints);\r\n        this.lastRenderedPath = [...path];\r\n\r\n        for (let i = 0; i < path.length; i++) {\r\n            let pathTile = document.querySelector(`[data-x=\"${path[i].x}\"][data-y=\"${path[i].y}\"]`);\r\n            pathTile.classList.add('ball--path');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets renders for board events.\r\n     */\r\n    setRenderForBoardEvents(): void {\r\n        this.board.instance.eventInterface.addEventListener('deletedBalls', (event: DeletedBallsEvent) => {\r\n            Renderer.clearDeletedBalls(event.detail.balls);\r\n\r\n            let pointsCountDOM = document.getElementById('js-points-count');\r\n            pointsCountDOM.innerText = (parseInt(pointsCountDOM.innerText) + event.detail.points).toString();\r\n        });\r\n\r\n        this.board.instance.eventInterface.addEventListener('gameEnded', (event: GameEndedEvent) => {\r\n            this.clearLastRenderedPath();\r\n            Renderer.renderBalls(event.detail.lastBalls);\r\n            Array.from(document.getElementsByTagName('td')).forEach(tile => {\r\n                tile.onclick = null;\r\n                tile.onmouseenter = null;\r\n                tile.onmouseout = null;\r\n            });\r\n\r\n            console.log('[INFO] Game lasted: ' + `${Math.round(event.detail.elapsedTime / 3600000 )}h ${Math.round(event.detail.elapsedTime / 60000)}m ${Math.round(event.detail.elapsedTime / 1000)}s`);\r\n            alert('Koniec gry. Twój wynik to: ' + event.detail.points);\r\n        });\r\n\r\n        this.board.instance.eventInterface.addEventListener('generatedBalls', (event: GeneratedBallsEvent) => Renderer.renderBalls(event.detail));\r\n\r\n        this.board.instance.eventInterface.addEventListener('previewedBalls', (event: PreviewedBallsEvent) => {\r\n            let colorPreviewDOM = document.getElementById('js-color-preview');\r\n            while (colorPreviewDOM.firstChild)\r\n                colorPreviewDOM.removeChild(colorPreviewDOM.firstChild);\r\n\r\n            for (let i = 0; i < event.detail.length; i++) {\r\n                let ballDOM = document.createElement('div');\r\n                ballDOM.className = 'ball ball-color--' + event.detail[i];\r\n                colorPreviewDOM.appendChild(ballDOM);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets all events for board tile.\r\n     * @private\r\n     * @param tile - board tile to set events for.\r\n     */\r\n    private setTileEvents(tile: HTMLTableCellElement): void {\r\n        tile.onclick = () => {\r\n            let tableAround = [{x: 0, y: -1}, {x: -1, y: 0}, {x: 1, y: 0}, {x: 0, y: 1}];\r\n            let takenTiles = 0;\r\n\r\n            for (let i = 0; i < tableAround.length; i++)\r\n              if (parseInt(tile.dataset.x) + tableAround[i].x >= 0 && parseInt(tile.dataset.x) + tableAround[i].x < this.board.width && parseInt(tile.dataset.y) + tableAround[i].y >= 0 && parseInt(tile.dataset.y) + tableAround[i].y < this.board.height)\r\n                  this.board.instance.getBoardMapTile(parseInt(tile.dataset.x) + tableAround[i].x, parseInt(tile.dataset.y) + tableAround[i].y).type !== BoardTilesTypes.none ? takenTiles++ : null;\r\n              else\r\n                takenTiles++;\r\n\r\n            if (takenTiles === 4 && !this.selectedStart)\r\n              return;\r\n\r\n            if (!this.selectedStart && this.board.instance.getBoardMapTile(parseInt(tile.dataset.x), parseInt(tile.dataset.y)).type !== BoardTilesTypes.none) {\r\n                this.endPoints.start = {\r\n                    x: parseInt(tile.dataset.x),\r\n                    y: parseInt(tile.dataset.y)\r\n                };\r\n\r\n                this.renderPathFlag = true;\r\n\r\n                if (this.selectedStart)\r\n                    this.selectedStart.children[0].classList.remove('ball--selected');\r\n\r\n                this.selectedStart = tile;\r\n                tile.children[0].classList.add('ball--selected');\r\n            } else if (this.selectedStart === tile) {\r\n                Object.assign(this.endPoints, {\r\n                    start: null,\r\n                    end: null\r\n                });\r\n\r\n                this.renderPathFlag = false;\r\n\r\n                this.selectedStart.children[0].classList.remove('ball--selected');\r\n                this.selectedStart = null;\r\n            } else if(this.selectedStart && this.board.instance.getBoardMapTile(parseInt(tile.dataset.x), parseInt(tile.dataset.y)).type !== BoardTilesTypes.none) {\r\n                this.endPoints.start = {\r\n                    x: parseInt(tile.dataset.x),\r\n                    y: parseInt(tile.dataset.y)\r\n                };\r\n\r\n                this.selectedStart.children[0].classList.remove('ball--selected');\r\n\r\n                this.selectedStart = tile;\r\n                tile.children[0].classList.add('ball--selected');\r\n            } else if (this.selectedStart && this.board.instance.getBoardMapTile(parseInt(tile.dataset.x), parseInt(tile.dataset.y)).type === BoardTilesTypes.none) {\r\n                this.endPoints.finish = {\r\n                    x: parseInt(tile.dataset.x),\r\n                    y: parseInt(tile.dataset.y)\r\n                };\r\n\r\n                if (this.board.instance.getPath(this.endPoints).length === 0)\r\n                    return this.endPoints.finish = null;\r\n\r\n                this.renderPathFlag = false;\r\n\r\n                this.selectedStart.children[0].classList.remove('ball--selected');\r\n                this.selectedStart = null;\r\n\r\n                let startDOM = document.querySelector(`[data-x=\"${this.endPoints.start.x}\"][data-y=\"${this.endPoints.start.y}\"]`);\r\n                let finishDOM = document.querySelector(`[data-x=\"${this.endPoints.finish.x}\"][data-y=\"${this.endPoints.finish.y}\"]`);\r\n                finishDOM.appendChild(startDOM.firstChild);\r\n\r\n                if (this.board.instance.moveBall(this.endPoints)) {\r\n                    this.selectedStart = null;\r\n                    this.clearLastRenderedPath(true, 500);\r\n                } else {\r\n                    console.log('[ERROR] Corrupted move. Trying to restore last known layout.');\r\n                    startDOM.appendChild(finishDOM.firstChild);\r\n                }\r\n            }\r\n        };\r\n\r\n        tile.oncontextmenu = (event) => {\r\n            event.preventDefault();\r\n\r\n            Object.assign(this.endPoints, {\r\n                start: null,\r\n                end: null\r\n            });\r\n\r\n            this.renderPathFlag = false;\r\n\r\n            if (this.selectedStart) {\r\n                this.selectedStart.children[0].classList.remove('ball--selected');\r\n                this.selectedStart = null;\r\n            }\r\n\r\n            this.clearLastRenderedPath();\r\n        };\r\n        document.getElementById('js-display').oncontextmenu = tile.oncontextmenu;\r\n\r\n        tile.onmouseenter = () => {\r\n            if (this.renderPathFlag)\r\n                this.renderPath(tile);\r\n        };\r\n\r\n        tile.onmouseout = () => {\r\n            if (this.renderPathFlag)\r\n                this.clearLastRenderedPath();\r\n        };\r\n    }\r\n}","import Collider from './Collider';\r\nimport {DeletedBallsEvent, GameEndedEvent, GeneratedBallsEvent, PreviewedBallsEvent} from '../types/events';\r\nimport {BoardInterface} from '../types/classes-interfaces';\r\nimport {BoardMapTile, BoardMapTileData, Coordinates, EndPoints} from '../types/interfaces';\r\nimport {BoardTilesColors, BoardTilesTypes, GameData} from '../config';\r\nimport {logStart, measurePerformance} from '../types/decorators';\r\nimport Pathfinder from './Pathfinder';\r\nimport Renderer from './Renderer';\r\nimport Tools from '../components/Tools';\r\n\r\nconsole.log('Loaded: Board.ts');\r\n\r\n\r\n/**\r\n * Class to create and manage game's board.\r\n */\r\nexport default class Board implements BoardInterface {\r\n  /** Interface to dispatch and listen custom events. */\r\n  readonly eventInterface: EventTarget;\r\n\r\n  /** Board height. */\r\n  private readonly height: number;\r\n  /** Board width. */\r\n  private readonly width: number;\r\n\r\n  /** Next balls colors that will be used. */\r\n  private ballsColorPreview: string[];\r\n\r\n  /** Map of board tiles. */\r\n  private readonly boardMap: BoardMapTile[][];\r\n  /** Map of free tiles. */\r\n  private readonly freeTiles: BoardMapTileData[];\r\n  /** Points gained by user. */\r\n  private points: number;\r\n  /** Timestamp of game start. */\r\n  private startTimestamp: Date;\r\n\r\n  /** Board's collider. */\r\n  private readonly collider: Collider;\r\n  /** Board's pathfinder. */\r\n  private readonly pathfinder: Pathfinder;\r\n  /** Board's renderer. */\r\n  private readonly renderer: Renderer;\r\n\r\n  /** Is finish point placed. */\r\n  private hasFinish: boolean;\r\n  /** Is start point placed. */\r\n  private hasStart: boolean;\r\n\r\n  /** Finish point coordinates. */\r\n  private finish: Coordinates;\r\n  /** Start point coordinates. */\r\n  private start: Coordinates;\r\n\r\n\r\n  /**\r\n   * Creates basic board data.\r\n   * @param height - board height.\r\n   * @param width - board width.\r\n   * @param ballsQuantity - initial balls quantity.\r\n   */\r\n  constructor(height: number, width: number, ballsQuantity?: number) {\r\n    this.height = height;\r\n    this.width = width;\r\n\r\n    this.boardMap = [];\r\n    this.freeTiles = [];\r\n\r\n    for (let i: number = 0; i < this.height; i++) {\r\n      let row = [];\r\n      for (let j: number = 0; j < this.width; j++) {\r\n        let newTile: BoardMapTile = {\r\n          color: null,\r\n          type: BoardTilesTypes.none,\r\n          x: j,\r\n          y: i\r\n        };\r\n\r\n        this.freeTiles.push(Object.assign({}, newTile));\r\n        row.push(newTile);\r\n      }\r\n\r\n      this.boardMap.push(row);\r\n    }\r\n\r\n    this.eventInterface = new EventTarget();\r\n    this.points = 0;\r\n    this.startTimestamp = new Date();\r\n\r\n    this.ballsColorPreview = [];\r\n    this.generateBallsColorPreview(ballsQuantity ? ballsQuantity : GameData.quantityOfInitialBalls);\r\n\r\n    this.hasFinish = false;\r\n    this.hasStart = false;\r\n\r\n    this.finish = {\r\n      x: null,\r\n      y: null\r\n    };\r\n\r\n    this.start = {\r\n      x: null,\r\n      y: null\r\n    };\r\n\r\n    this.collider = new Collider(this.height, this.width);\r\n    this.pathfinder = new Pathfinder(this.height, this.width);\r\n    this.renderer = new Renderer(this, this.height, this.width);\r\n  }\r\n\r\n  /**\r\n   * Checks if there are balls in pattern that can be killed, then kills them.\r\n   * @private\r\n   */\r\n  private checkBoardThenDeleteBalls() {\r\n    let deepCopyBoardMap = JSON.parse(JSON.stringify(this.boardMap));\r\n    let tilesToPurge: BoardMapTileData[] = this.collider.checkAllAxis(deepCopyBoardMap);\r\n\r\n    // kill balls if there are any\r\n    if (tilesToPurge.length > 0) {\r\n      // award points\r\n      this.points += tilesToPurge.length;\r\n\r\n      // create and dispatch custom event to eventInterface, (with points and killed balls array)\r\n      let event: DeletedBallsEvent = new CustomEvent('deletedBalls', {\r\n        detail: {\r\n          balls: tilesToPurge,\r\n          points: tilesToPurge.length\r\n        }\r\n      });\r\n      this.eventInterface.dispatchEvent(event);\r\n\r\n      // clear balls in boardMap\r\n      for (let i = 0; i < tilesToPurge.length; i++) {\r\n        this.updateFreeTiles(tilesToPurge[i].x, tilesToPurge[i].y, tilesToPurge[i].color, 'add');\r\n        this.writeBoardMap(tilesToPurge[i].x, tilesToPurge[i].y, null, BoardTilesTypes.none);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates balls on the board.\r\n   * @private\r\n   * @param quantity - balls quantity.\r\n   */\r\n  @measurePerformance('balls generation')\r\n  private generateBalls(quantity: number): void {\r\n    let initialQuantity = quantity;\r\n    let newBalls: BoardMapTileData[] = [];\r\n    while (quantity) {\r\n      let randomTile = this.freeTiles[Tools.getRandomIntInclusive(0, this.freeTiles.length - 1)];\r\n\r\n      if (this.readBoardMap(randomTile.x, randomTile.y).type === BoardTilesTypes.none) {\r\n        newBalls.push({\r\n          color: this.ballsColorPreview[quantity - 1],\r\n          type: BoardTilesTypes.obstacle,\r\n          x: randomTile.x,\r\n          y: randomTile.y\r\n        });\r\n\r\n        this.updateFreeTiles(randomTile.x, randomTile.y, this.ballsColorPreview[quantity - 1], 'delete');\r\n        this.writeBoardMap(randomTile.x, randomTile.y, this.ballsColorPreview[quantity - 1], BoardTilesTypes.obstacle);\r\n        quantity--;\r\n      } else {\r\n        console.error(`tile ${randomTile.x} ${randomTile.y} wasn't free`)\r\n      }\r\n\r\n      // end game if all spaces are taken\r\n      if (this.freeTiles.length <= 0) {\r\n        let record = localStorage.getItem('balls_record');\r\n        if (!record || this.points > parseInt(record))\r\n          localStorage.setItem('balls_record', this.points.toString());\r\n\r\n        let event: GameEndedEvent = new CustomEvent('gameEnded', {\r\n          detail: {\r\n            elapsedTime: Date.now() - this.startTimestamp.getTime(),\r\n            lastBalls: newBalls,\r\n            points: this.points\r\n          }\r\n        });\r\n        this.eventInterface.dispatchEvent(event);\r\n        return;\r\n      }\r\n    }\r\n    this.generateBallsColorPreview(initialQuantity);\r\n\r\n    let event: GeneratedBallsEvent = new CustomEvent('generatedBalls', {\r\n      detail: newBalls\r\n    });\r\n    this.eventInterface.dispatchEvent(event);\r\n  }\r\n\r\n  /**\r\n   * Generates colors for next balls.\r\n   * @private\r\n   * @param quantity - balls quantity.\r\n   */\r\n  private generateBallsColorPreview(quantity: number) {\r\n    let colors: string[] = [];\r\n    for (let i = 0; i < quantity; i++)\r\n      colors.push(BoardTilesColors[Tools.getRandomIntInclusive(0, BoardTilesColors.length - 1)].id);\r\n    this.ballsColorPreview = colors;\r\n\r\n    let event: PreviewedBallsEvent = new CustomEvent('previewedBalls', {\r\n      detail: colors\r\n    });\r\n    this.eventInterface.dispatchEvent(event);\r\n  }\r\n\r\n  /**\r\n   * Returns board tile from BoardMap.\r\n   * @param x - horizontal coordinate of tile.\r\n   * @param y - vertical coordinate of tile.\r\n   * @return boardTile - board tile.\r\n   */\r\n  getBoardMapTile(x: number, y: number): BoardMapTile {\r\n    return this.readBoardMap(x, y);\r\n  }\r\n\r\n  /**\r\n   * Gets the path, from pathfinder, between two points.\r\n   * @param endpoints - start and end points of path.\r\n   */\r\n  getPath(endpoints: EndPoints): Coordinates[] {\r\n    if (this.readBoardMap(endpoints.finish.x, endpoints.finish.y).type === BoardTilesTypes.obstacle)\r\n      return [];\r\n\r\n    let deepCopyBoardMap = JSON.parse(JSON.stringify(this.boardMap));\r\n\r\n    deepCopyBoardMap[endpoints.finish.y][endpoints.finish.x].type = BoardTilesTypes.finish;\r\n    deepCopyBoardMap[endpoints.start.y][endpoints.start.x].type = BoardTilesTypes.start;\r\n\r\n    return this.pathfinder.findPath(deepCopyBoardMap);\r\n  }\r\n\r\n  /**\r\n   * Moves ball between two points.\r\n   * @param endpoints - points from and to which ball will be moved.\r\n   */\r\n  moveBall(endpoints: EndPoints): boolean {\r\n    if (this.boardMap[endpoints.finish.y][endpoints.finish.x].type !== BoardTilesTypes.none)\r\n      return false;\r\n\r\n    if (this.getPath(endpoints).length === 0)\r\n      return false;\r\n\r\n    let startPointData: BoardMapTileData = this.readBoardMap(endpoints.start.x, endpoints.start.y);\r\n\r\n    this.updateFreeTiles(endpoints.finish.x, endpoints.finish.y, startPointData.color, 'delete');\r\n    this.updateFreeTiles(endpoints.start.x, endpoints.start.y, null, 'add');\r\n\r\n    this.writeBoardMap(endpoints.finish.x, endpoints.finish.y, startPointData.color, startPointData.type);\r\n    this.writeBoardMap(endpoints.start.x, endpoints.start.y, null, BoardTilesTypes.none);\r\n\r\n    this.checkBoardThenDeleteBalls();\r\n    this.generateBalls(GameData.quantityOfRoundBalls);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Reads tile from BoardMap.\r\n   * @private\r\n   * @param x - horizontal coordinate of tile.\r\n   * @param y - vertical coordinate of tile.\r\n   * @return tile - odczytany kafelek.\r\n   */\r\n  private readBoardMap(x: number, y: number): BoardMapTile {\r\n    let deepCopyBoardMapTile = JSON.parse(JSON.stringify(this.boardMap));\r\n    return deepCopyBoardMapTile[y][x];\r\n  }\r\n\r\n  /**\r\n   * Updates freeTiles list.\r\n   * @private\r\n   */\r\n  private updateFreeTiles(x: number, y: number, color: string, action: 'add' | 'delete'): void {\r\n    if (action === 'add')\r\n      this.freeTiles.push({\r\n        color: color,\r\n        type: BoardTilesTypes.obstacle,\r\n        x: x,\r\n        y: y\r\n      });\r\n    else {\r\n      let tileToDelete = this.freeTiles.find(tile => tile.x === x && tile.y === y);\r\n      if (tileToDelete)\r\n        this.freeTiles.splice(this.freeTiles.indexOf(tileToDelete), 1);\r\n      else\r\n        console.error('Data corrupted!');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Starts and handles game progress.\r\n   * @param initialObstaclesCount - initial obstacle quantity.\r\n   */\r\n  @logStart\r\n  startGame(initialObstaclesCount: number): void {\r\n    this.renderer.renderBoard();\r\n    this.renderer.setRenderForBoardEvents();\r\n    this.generateBalls(initialObstaclesCount);\r\n  }\r\n\r\n  /**\r\n   * Writes tile in BoardMap.\r\n   * @private\r\n   * @param x - horizontal coordinate of tile.\r\n   * @param y - vertical coordinate of tile.\r\n   * @param color - new color.\r\n   * @param type - new type.\r\n   */\r\n  private writeBoardMap(x: number, y: number, color: string, type: string): void {\r\n    Object.assign(this.boardMap[y][x], {\r\n      color: color,\r\n      type: type\r\n    });\r\n  }\r\n}","import Board from './classes/Board';\r\nimport {GameData} from './config';\r\n\r\nconsole.log('Loaded: app.ts');\r\n\r\n\r\nimport './css/fonts.css';\r\nimport './css/master.css';\r\nimport './css/balls.css';\r\nimport './css/dev.css';\r\n\r\nwindow.addEventListener('DOMContentLoaded', () => {\r\n  if (localStorage.getItem('balls_record'))\r\n    document.getElementById('js-points-record').innerText = localStorage.getItem('balls_record');\r\n\r\n  let board: Board = new Board(9, 9);\r\n  board.startGame(GameData.quantityOfInitialBalls);\r\n});"],"names":["BoardTilesColors","id","name","BoardTilesTypes","measurePerformance","message","target","propertyKey","descriptor","originalMethod","value","args","start","performance","now","result","apply","this","finish","console","log","Tools","static","min","max","Math","ceil","floor","random","array","filter","v","i","a","findIndex","t","JSON","stringify","Collider","constructor","height","width","board","checkAllAxis","boardMap","tilesToPurge","concat","checkAxis","checkSlants","removeArrayDuplicates","direction","arrDirectionFirst","arrDirectionSecond","colorOccurrences","tile","tileColor","color","pushNext","tilesList","j","x","y","nextTile","push","checkSlant","Pathfinder","debugMode","searchOffsetArr","checkIfEndPointsAreNeighbors","boardProcess","length","checkOffsetOutOfIndex","type","tileData","offsetID","findPath","pathHelper","wasSearched","Object","assign","error","foundFinish","tilesToCheckArr","tilesToCheckArrCopy","tileToCheck","tileAround","splice","indexOf","reverseSearch","pathArr","lastTile","pathCreated","lastTileBeforeSearch","selectedTile","Array","Renderer","instance","renderPathFlag","selectedStart","endPoints","lastRenderedPath","element","display","document","getElementById","firstChild","removeChild","appendChild","balls","querySelector","remove","clearLastRenderedPath","hasAfterimage","duration","copyLastRenderedPath","pathTile","classList","add","setTimeout","renderBoard","boardDOM","createElement","row","cell","setAttribute","toString","setTileEvents","clearAndAppendDisplay","ballsArr","ballData","ball","renderPath","endpoints","parseInt","dataset","path","getPath","setRenderForBoardEvents","eventInterface","addEventListener","event","clearDeletedBalls","detail","pointsCountDOM","innerText","points","renderBalls","lastBalls","from","getElementsByTagName","forEach","onclick","onmouseenter","onmouseout","round","elapsedTime","alert","colorPreviewDOM","ballDOM","className","tableAround","takenTiles","getBoardMapTile","end","children","startDOM","finishDOM","moveBall","oncontextmenu","preventDefault","Board","ballsQuantity","freeTiles","newTile","EventTarget","startTimestamp","Date","ballsColorPreview","generateBallsColorPreview","hasFinish","hasStart","collider","pathfinder","renderer","checkBoardThenDeleteBalls","deepCopyBoardMap","parse","CustomEvent","dispatchEvent","updateFreeTiles","writeBoardMap","generateBalls","quantity","initialQuantity","newBalls","randomTile","getRandomIntInclusive","readBoardMap","record","localStorage","getItem","setItem","getTime","colors","startPointData","action","tileToDelete","find","startGame","initialObstaclesCount","window"],"sourceRoot":""}